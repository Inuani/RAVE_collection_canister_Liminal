type Actor = service {
  add_protected_route : (text) -> ();
  append_route_cmacs : (text, vec text) -> ();
  commit_batch : (CommitBatchArguments) -> ();
  create_batch : (record {}) -> (CreateBatchResponse);
  create_chunk : (CreateChunkArguments) -> (CreateChunkResponse);
  create_chunks : (CreateChunksArguments) -> (CreateChunksResponse);
  get_route_cmacs : (text) -> (vec text) query;
  get_route_protection : (text) -> (opt ProtectedRoute) query;
  http_request : (RawQueryHttpRequest) -> (RawQueryHttpResponse) query;
  http_request_streaming_callback : (StreamingToken) -> (
      StreamingCallbackResponse,
    ) query;
  http_request_update : (RawUpdateHttpRequest) -> (RawUpdateHttpResponse);
  list : (record {}) -> (vec AssetDetails) query;
  update_route_cmacs : (text, vec text) -> ();
};
type AssetDetails = record {
  key : Key;
  encodings : vec AssetEncodingDetails;
  content_type : text;
};
type AssetEncodingDetails = record {
  modified : Time;
  sha256 : opt blob;
  length : nat;
  content_encoding : text;
};
type BatchId = nat;
type BatchOperationKind = variant {
  SetAssetProperties : SetAssetPropertiesArguments;
  CreateAsset : CreateAssetArguments;
  UnsetAssetContent : UnsetAssetContentArguments;
  DeleteAsset : DeleteAssetArguments;
  SetAssetContent : SetAssetContentArguments;
  Clear : ClearArguments;
};
type CallbackStreamingStrategy = record {
  token : StreamingToken;
  callback : StreamingCallback;
};
type ChunkId = nat;
type ClearArguments = record {};
type CommitBatchArguments = record {
  batch_id : BatchId;
  operations : vec BatchOperationKind;
};
type CreateAssetArguments = record {
  key : Key;
  content_type : text;
  headers : opt vec Header;
  allow_raw_access : opt bool;
  max_age : opt nat64;
  enable_aliasing : opt bool;
};
type CreateBatchResponse = record { batch_id : BatchId };
type CreateChunkArguments = record { content : blob; batch_id : BatchId };
type CreateChunkResponse = record { chunk_id : nat };
type CreateChunksArguments = record { content : vec blob; batch_id : BatchId };
type CreateChunksResponse = record { chunk_ids : vec ChunkId };
type DeleteAssetArguments = record { key : Key };
type Header = record { text; text };
type Key = text;
type ProtectedRoute = record {
  cmacs : vec text;
  path : text;
  scan_count : nat;
};
type RawQueryHttpRequest = record {
  url : text;
  method : text;
  body : blob;
  headers : vec Header;
  certificate_version : opt nat16;
};
type RawQueryHttpResponse = record {
  body : blob;
  headers : vec Header;
  upgrade : opt bool;
  streaming_strategy : opt StreamingStrategy;
  status_code : nat16;
};
type RawUpdateHttpRequest = record {
  url : text;
  method : text;
  body : blob;
  headers : vec Header;
};
type RawUpdateHttpResponse = record {
  body : blob;
  headers : vec Header;
  streaming_strategy : opt StreamingStrategy;
  status_code : nat16;
};
type SetAssetContentArguments = record {
  key : Key;
  sha256 : opt blob;
  chunk_ids : vec ChunkId;
  content_encoding : text;
};
type SetAssetPropertiesArguments = record {
  key : Key;
  headers : opt opt vec Header;
  is_aliased : opt opt bool;
  allow_raw_access : opt opt bool;
  max_age : opt opt nat64;
};
type StreamingCallback = func (StreamingToken) -> (
    StreamingCallbackResponse,
  ) query;
type StreamingCallbackResponse = record {
  token : opt StreamingToken;
  body : blob;
};
type StreamingStrategy = variant { Callback : CallbackStreamingStrategy };
type StreamingToken = blob;
type Time = int;
type UnsetAssetContentArguments = record { key : Key; content_encoding : text };
service : () -> Actor